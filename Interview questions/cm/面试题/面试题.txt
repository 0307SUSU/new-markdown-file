媒体查询：
text：text password
颜色：
浮动：
伪类：before after ahlv 
sass如何实现继承？
客户端如何和服务器请求？
get 和post的区别？


如何判断当前用户使用的浏览器？
深拷贝，和浅拷贝的区别?



如何设置边框？
如果设置半透明？
如何设置呈圆形展示？
微信页面布局？
盒模型？

怪异盒模型和正常合模型的区别？

js常见的数据类型：

列举一下数组中常见的方法？


3day
在js中获取dom的哪几种方法？
什么是闭包？
js事件传播流程？
伪类操作，


4day
监听，和on事件的区别？
onload 
刷新。

浏览器：

请求状态码：
字符串中的

www万维网
http网络协议/https？
html 超文本语言


html语义标签

css新增的
常见的盒模型：区别
移动端eps问题解决问题。
es6新增：？
const let区别？
严格模式？
异步和同步的区别？
递归实际运用？
深拷贝和浅拷贝的区别？

数组里常用的方法？
数组中如何删除一个元素？splice
数组倒叙，sort（b-a）
字符串截取方法？
字符串中是否包含某个字符？

如何设置一个颜色半透明？rfba 
边框设置圆角效果？
设置水平居中?


适配怎么处理？

闭包？

设计模式有哪些？
数组常见的排序方法？
排序算法？
h5新增优化标签？
vi-if和v-show区别？
vue 里的key的作用？为什么key不能用索引？
vue里的计算属性的作用？和监听的区别？

嵌套组件的生命中周期是如何实现的？

px ，rem，em的区别？
圆角效果？
图片放大的css、、？
js常见的数据类型有哪些？
数组删除？
如何获取所有对象的属性名？

--------------------------------------------------------------
什么是闭包，有什么特性和优缺点，以及使用:
一.闭包：定义在一个函数内部的函数。其中一个内部函数在包含它们的外部函数之外被调用时，就会形成闭包。
二.特点：①：函数嵌套函数
 ②：函数内部可以引用外部的参数和变量
 ③：参数和变量不会被垃圾回收机制回收
三.优点：①：变量长期驻扎在内存中
 ②：避免全局变量的污染
 ③：私有成员的存在
       四.缺点:   ①：会造成内存泄露
五.使用：①：读取函数内部的变量
 ②：这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除
5.什么是事件委托:事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是DOM元素的事件冒泡
node.addEventListener('事件类型',function(){},false)
当为false时，是事件冒泡---默认是false
当为true时，是事件捕获

6.什么是事件冒泡：事件首先被最内层元素捕获并处理，然后传播到外部元素(由内到外)
7.什么是事件捕获：事件首先由最外层元素捕获并传播到内部元素(由外到内)
8.事件委托的优缺点：
优点：①提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用
   ②动态的添加DOM元素，不需要因为元素的改动而修改事件绑定
缺点:  ①事件委托有对子元素的查找过程，委托层级过深，可能会有性能问题


.数组的方法有那些：
①push()--从后面添加元素，返回值是添加完后数组的长度
②arr.pop()--从后面删除元素，只能是一个，返回值是删除的元素
③arr.unshift()--从前面添加元素，返回值是添加完后的数组的长度
④arr.shift()--从前面删除一个元素，只能删除一个，返回值是删除的元素
⑤arr.splice(i,n)--删除从i(下标)开始之后的那个元素，返回值是删除的元素
⑥arr.concat()--连接两个数组，返回值为连接后的新数组
⑦str.split()--将字符串转化为数组
⑧arr.sort()--将数组进行排序，返回值是排序好的数组
⑨arr.reverse()--将数组反转，返回值是反转后的数组
⑩arr.slice(start，end)--截取数组开始索引到结束索引的值，不包含结束索引的值，返回值是截取后的数组
①①arr.forEach(callBack)--遍历数组，没有return，即使有return，也没有返回值，并不会影响原来的数组
①②arr.map(callBack)--映射数组(遍历数组)，有return，返回一个新数组
①③arr.filter(callBack)--过滤数组，返回一个满足要求的数组

1.什么是原型:每个构造函数都有一个原型属性prototype，保存了所有用构造函数实例化出来的对象方法，用构造函数创建了一个对象，这个对象上会有一个属性__proto__指向构造函数的原型属性，当使用一个对象的属性或者方法的时候，首先在自身内存查找，找到就用，找不到，就去原型上找
2.什么是原型链:当我们使用一个属性的属性，首先在自身中查找，如果有就用，如果没有就去原型里面找，arr1的原型是arr1.__proto__,也就是Array.prototype，原型本质上就是一个对象，对象有自己的原型，如果原型没有这个方法，就去原型的原型中查找，arr1.__proto__.__proto__或Array.prototype.__proto__(是用object构造函数创建的)
最后找到 Object.prototype 如果 Object.prototype 也没有这个属性最后值是underfind
Object.prototype是没有_proto_属性的，它==null。


.什么是防抖和节流,两者有什么区别,怎么实现,以及应用场景：
①防抖:触发高频事件后n秒内只执行一次，只有满足一定的时间，才会执行一次代码，如果n秒内再次触发就重新计算时间。
实现：let ipt = document.querySelector('input');
    function debounce(fn, wait){
      // 使用闭包保存永久的变量
      let timeout = null;
      return function() {
        // 每当用户输入的时候把前一个定时器取消掉，这样来保证只有不触发事件时才开始计时
        clearTimeout(timeout);
        timeout = setTimeout(fn, wait);}
    }
    function handler(){
      console.log('防抖成功');}
    ipt.addEventListener('input',debounce(handler,1000));

②节流:高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率
实现: function debouce(fn){
      //先创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function(timeout){
        // 没当用户输入的时候把前一个setTimeout clear掉
        timeout = setTimeout(() => {
          // 然后创建一个新的setTimeout,这样能保证输入的字符后的间隔内如果还有字符输入的话,就不会在执行fn这个函数
          fn.apply(this,arguments);
        },500);
      };
    }
    function sayHi() {
        console.log('节流成功');
      }
    ipt.addEventListener('input',debouce(sayHi))

区别:函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。
应用场景:
1.防抖:①登录,发送短信等按钮避免用户点击太快,以至于发送了很多请求
   ②文本编辑时保存,当无任何更改操作一秒后进行保存
   ③防抖重在清零clearTimeout(timer)
    ④调整浏览器窗口大小时,resize次数过于频繁,造成计算过多,此时需要一次到位
2.节流:①scroll事件,每隔一秒计算一次位置信息等
   ②浏览器播放事件,每个一秒计算一次进度信息等
   ③input框实时搜索并发送请求展示下拉列表,每隔一秒发送一次请求
   ④节流重在开关锁timer = null


ajax优缺点1.对搜索引擎不好
	2.没有前进和后退
	3.安全性比较低（可以看见请求信息）
	4.





px/em/rem/vh/vw
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的
em是相对长度单位。相对于当前父元素的字体尺寸。如未设置，则相对于浏览器的默认字体尺寸
rem是CSS3新增的一个相对单位。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素
css3新单位，view width的简写，是指可视窗口的宽度。假如宽度是1200px的话。那10vw就是120px
css3新单位，view height的简写，是指可视窗口的高度。假如高度是1200px的话。那10vh就是120px
*******************************************
如何理解MVVM原理？？
1.

*********************
2.vue响应式原理？
Vue 的响应式，核心机制是 观察者模式。

*************************************************

********************************************************



6.Ajax应该放在哪个生命周期里。
	created

7.Vue.js 何时需要使用 beforeDestroy
	可能在当前页面中使用了$on方法，那需要在组件销毁前解绑。
	清除自己定义的定时器
	解除事件的绑定 scroll mousemove ....

