									面试题总结
							js

  xs攻击

浏览器缓存策略：
                    本地缓存阶段（强制缓存）
                      浏览器发送请求前，会先去缓存里查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器。否则，进入下一步。
                   协商缓存阶段
                       当强缓存没有命中时，浏览器一定会向服务器发起请求。
                       服务器会根据 Request Header 中的一些字段来判断是否命中协商缓存。
                       如果命中，服务器会返回 304 响应，但是不会携带任何响应实体，只是告诉浏览器可以直接从浏览器缓存中获取这个资源。
                       如果本地缓存和协商缓存都没有命中，则直接从服务器加载资源。


setState的同步与异步：
                  setState在生命周期和合成事件中是异步；
                  在原生事件和异步方法里面是同步；
                  setState异步实际上是生命周期和合成事件在更新之前被调用，导致他们拿到的数据不是更新后的值。
                   
          setState在生命周期和合成事件中会进行批量更新优化，即对同一个key进行多次setState，只取最后一次执行。
           如果是更新多个key，在更新时合并批量更新。



1.作用域 作用域链
	作用域：在一定的空间里可以对数据进行读写操作，这个空间就是作用域
		1.全局作用域：最外层函数定义的变量拥有全局作用域，任何内部函数都是可以访问的
		2.局部作用域：局部作用域一般只是在固定的代码片段内可以访问到，对于外部函数是无法访问的
	作用域链：当所需要的变量在作用域中查找不到的时候，它会一层一层向上查找，直到全局作用域还没有找到的时候，就会放弃查找。这一层一层的关系就叫作用域链

2.什么是闭包
	闭包：函数的嵌套形成闭包，闭包就是能够读取到其他函数内部变量的函数
	闭包的用处：1.可以读取函数内部的变量
		    2.可以让这些变量的值始终保持在内存中
	           缺点：
		1.内存消耗大，会造成页面的性能问题，在ie中可能导致内存泄漏
		2.闭包会在父函数外部，改变父函数变量的值
	使用闭包的常用场景：
		1.通过循环给页面上多个dom节点绑定事件
		2.封装变量
		3.延续变量的使用寿命
	闭包引起的内存泄露
		原因：闭包可以维持函数内部局部变量，使其得不到释放
		解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用
3.原

4.this指向问题
	普通函数调用：1.this指向全局对象window
		       2.在严格模式下，没有直接调用者的函数中的this是 undefind
		       3.使用call，apply，bind绑定的，this指的是绑定的对象
			call、apply、bind的区别：
				bind会有一个返回值，返回值是一个函数，因此要加上（）才能调用；
				call、apply是没有返回值的，当改变this指向的时候，不需要加（）就会执行
				call传递参数的时候是一个一个传递的，apply是传递一个数组
	对象函数调用：谁调用this就指向谁
	构造函数调用：this指向实例对象
	箭头函数调用：箭头函数的this是在定义函数的时候绑定的，不是在执行过程中绑定  
		       可以解决匿名函数和定时器的this指向问题，不用用变量that储存this
5.跨域
	什么是跨域：协议、域名、端口号相同被称为同源策略，由王景公司提出，不同就为跨域、
 	如何解决：
		1.jsonp    
			实现原理  
				动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入
			优缺点
				优点：兼容性好    缺点：只支持get请求
		2.跨域资源共享
			实现原理
				服务器对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
		
		3.跨域代理

6.promise
	promise是一个构造函数，有all、reject、resolve方法，原型上有then、catch等方法
        执行原理：
	Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。
7.什么是深浅拷贝    实现方法
	区别：假设B复制了A，当修改B时，看A是否会发生变化，如果A也跟着变了，说明这是浅拷贝，如果A没变，那就是深拷贝。
	浅拷贝：仅仅拷贝对象自身，内部元素引用的其他对象只拷贝一个引用
	深拷贝：外围和内部元素都拷贝了对象本身，而不是引用。因此深拷贝产生的副本可以随意修改，而不会影响原始值
8.什么会引发内存泄漏
	循环、闭包	
9.http状态码
	200：请求成功
	301：代表永久性转移、
	302：代表暂时性转移
	4xx：客户端异常
	401：未授权，一些请求需要服务端授权，但是又未得到授权
	403：服务器拒绝了你的地址请求
	404：未找到请求资源
	405：方法禁用  例如：使用post方法请求静态文件，但静态文件又不允许post方法请求；接口定义的是post请求，但是调用时用get，也会返回405
	406：请求的文本格式和响应式的文本格式不一样    如请求的是application/json，但响应式text/html
	407：代理服务器未授权，客户端使用代理服务器访问服务端，而代理服务器又未得到授权
	500：服务端异常
	503：是一种http协议的服务端错误状态代码，它表示服务器尚未处于可以接收请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载
什么是http？
	应用端的协议
	特点：无状态，基于TCP/IP协议
	http请求构成：请求行、请求头、内容实体组成（注意，每一行的末尾都有回车和换行，在内容实体和请求头之间另有一个空行）
		1.请求行：指定的是请求方法、请求URL、协议版本
		2.请求头：键值对的形式存在，就是字段名：值；比如希望得到的文本的返回格式，字符集，编码，连接时间等
		3.内容实体就是传输的数据

10.什么是https？
	https是基于http协议和ssl/tls协议的，通信时使用密文进行传输，并且校验通信双方的身份来保证通信安全
	请简述https时如何保住信息安全的 ：https采用混合加密的方式，并且有数字证书认证机构来保证信息的安全
			              过程：需要知道两个名词公开密钥加密方式（公钥加密私钥解密）和共享密钥加密方式（加密和解密的密钥一样）
11.Es6新增的语法
	1.let、const声明变量
	2.箭头函数
	3.解构赋值
	4.Moudles（模块）
	5.模板字符串
	6.class类 
	7.promise
	8.JSON

12，JavaScript 的数据类型都有什么？ 
基本数据类型：String, boolean, Number, Undefined（未定义）, Null(空对象) 
引用数据类型：Object(Array,Date,RegExp,Function) 


                   							vue
1.vue双向数据绑定的原理是什么
	vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调
	
2.vue的生命周期
	beforeCreate 创建前
	created创建后
	beforeMount载入前
	mounted载入后
	beforeUpdata更新前
	updated更新后
	beforeDestory销毁前
	destoryed销毁后
什么是vue的生命周期？
	vue实例从创建的销毁的过程，就是生命周期。
	从开始创建、初始化数据、编译模板、挂载Dom--渲染、更新--渲染、销毁等一系列过程，称之为vue的生命周期
3.vue数据双向绑定的原理
	1.使用Object.defineProtype进行数据劫持，把data对象、computed等里的所有属性进行数据劫持。
	2.当data对象里的属性的值发生变化时，就会发布，发布时，就改变了dom里的内容
4.组件传值
        父组件向子组件传值：props
        子组件向父组件传值：$emit
	
5. vue常用的修饰符
                 .prevent：交事件不在重载页面   
	.stop:阻止单击事件冒泡
	.self当事件发生在该元素本身而不是子元素的时候会触发
	.capture：事件监听，事件发生的时候会调用
     
	
	
	



								react
1.生命周期函数
	组件将要挂载时触发的函数：componentWillMount
	组件挂载完成时触发的函数：componentDidMount
	是否要更新数据时触发的函数：shouldComponentUpdate
	将要更新数据时触发的函数：componentWillUpdate
	数据更新完成时触发的函数：componentDidUpdate
	组件将要销毁时触发的函数;componentWillUnmount
	父组件中改变了props传值时触发的函数：componentWillReceiveProps

	react执行顺序	
		初始化阶段：组件即将开始并进行dom
			getDefaultProps:获取实例的默认属性
			getInitialState:获取每个实例的初始化状态
			componentWillMount：组件即将被装载，渲染到页面上
			render：组件在这里生成虚拟的DOM节点
			componentDidMount：组件真正在被装载之后
		运行中状态：一旦组件被添加到dom，状态发生变化时
			componentWillReceiveProps:组件将要接收到属性的时候调用
		react在哪个钩子函数中做优化？	shouldComponentUpdate：组将接收到新属性或者新状态的调用
			componentWillUpdate:组件即将更新不能修改属性和状态
			render：组件重新描绘
			componentDidUpdate：组件已经更新
		销毁阶段：组件将被销毁并从dom中删除
			componentWillUnmount：组件即将销毁
	

                                              
			useState:存状态
			usememo：
           useEffect模仿了生命周期：
		     DidMount()
                                       DidUpdate()
                                          WillUnmount()  和依赖项没有

			
2.什么是虚拟Dom
	虚拟dom就是使用javascript模拟了dom结构的树形结构，这个树形结构包含了整个dom结构的信息
	相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没必要的都没操作，从而提高性能
	用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。	
	然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。
	
为什么要使用虚拟dom？
                             因为当使用原生js和jq操作dom是很麻烦的一件事情，并且代码会显的非常冗余混乱，耦合性高难以维护，并且浏览器一遍一遍渲染dom非常消耗性能，
                             所以尽量减少dom操作成为了优化前端性能的必要手段，虚拟dom就是将dom的对比放在js层，通过不同之处来渲染新的dom节点，提高渲染效率


3.diff算法

	 
4.什么是高阶组件？
（高阶函数就是一个纯js没有副作用的函数）
	高阶组件就是一个react组件包裹另一个react组件
	因为要访问它的状态，所以要用到继承
	高阶组件就是一个函数，它接收另一个组件作为参数，并返回一个新的组件
	React 中的高阶组件主要有两种形式：属性代理 和 反向继承。

      优势：更具有重复性、逻辑性、抽象特性
      高阶组件的使用场景？
		
5.为什么react Router v4中使用swich关键字
	虽然div中封装多个路由，但当你向要仅显示在多个定义的路线中呈现单个路线时，可以使用swich，使用时swich标记会按照顺序已定的url与定义的路	由进行匹配
6.react组件通信如何实现
	父组件向子组件：父组件定义一个属性，子组件通过this.props接收
	子组件向父组件：父组件定义一个属性，并将一个回调函数赋值给定义的属性，然后子组件进行调用传过来的函数，并将参数传进去，在父组件的回调函数中即可获得子组件传过来的值 
	兄弟组件：找到两个兄弟节点共同的父节点，结合以上两种方式由父节点转发信息进行通信
	跨层级通讯：Context  共享那些对于一个组件树是全局的数据
	发布订阅者模式：发布者发布事件、订阅者监听事件，我们可以引入event模块进行通信
	全局状态管理工具：借助Redux或者Mobx等全局状态管理工具进行通讯	

7,  this.setState 异步的理解

	在执行this.setState的时候会先把所有的代码执行一遍，最后在同一处理this.setState的更改，
	所以在某些特定情况下会呈现异步，这种特点情况是事件回调函数和生命周期钩子函数

8， react事件处理方式

	React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同:

	React 事件绑定属性的命名采用驼峰式写法，而不是小写。
	如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素的写法)

9、state和props之间有什么不同


登录注册

 
		
1、Redux是什么?

多组件共享的状态管理库

Redux是当今市场上最热门的前端开发库之一。

它是JavaScript应用程序的可预测状态容器，用于整个应用程序的状态管理。

使用Redux开发的应用程序易于测试，可以在不同的环境中运行，表现出一致的行为。


2、Redux遵循的三个原则是什么?

单个事实来源：整个应用程序的状态存储在单个存储中的对象/状态树中。

	单状态树使跟踪随时间的变化和调试或检查应用程序变得更容易。

状态是只读的：更改状态的惟一方法是触发一个动作。

	一个动作是一个普通的JS对象，用来描述变化。

	就像state是数据的最小表示一样，action是数据更改的最小表示。

使用纯函数进行更改：为了指定如何通过操作转换。

         Redux


3、Redux异步
	axios调接口


4、Redux整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
2. 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State
3. State一旦有变化，Store就会调用监听函数，来更新View。
到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。


1、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么?(流程说的越详细越好)

		浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求;

		服务器交给后台处理完成后返回数据，浏览器接收文件(HTML、JS、CSS、图 象等);

		浏览器对加载到的资源(HTML、JS、CSS 等)进行语法解析，建立相应的内部 数据结构(如 HTML 的 DOM);

    		载入解析到的资源文件，渲染页面，完成。


对于 MVVM 的理解？
   MVVM 的优点
 1、主要目的是模型（Model）和分离视图（View）
 2、降低代码耦合，提高视图或者逻辑的重用性。
 3、提高了模块的可测试性


字符串反转
1、字符串转数组，反转数组，数组转字符串。
split("")：根据空字符串拆分数组

reverse()：数组反转元素位置

join("")：数组转回字符串,且不带分隔符



数组最大值
   1、循环对比
   2、递归对比
         Math.max

                           43、javascript继承的 6 种方法？
                                       1、原型链继承
                                       2. 借用构造函数继承
                                       3. 组合继承(原型+借用构造)
                                       4. 原型式继承
                                       5. 寄生式继承
                                       6. 寄生组合式继承

css水平垂直居中

                         闭包
          闭包：函数的嵌套形成闭包，闭包就是能够读取到其他函数内部变量的函数
 
                         foreach  map区别
           foreach没有返回值    map有返回值
 
                   箭头函数和普通函数的区别
            this指问题：箭头函数谁调用指向谁。   普通函数如果调用就指向自身，不调用就指向window

                                   数组去重
                               1、遍历数组法

                                 promise的封装

                                   调用接口排错
 
                                 
    es6的新增语法
1.let、const声明变量
2.箭头函数
3.解构赋值
4.Moudles（模块）
5.模板字符串
6.class类 
7.promise



数组循环   
1.forEach()
2.map()
3.filter()
4.reduce() 
5.every()
6.some()


防抖和节流
所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。


     重绘和回流
 页面的元素规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。
只是影响元素的外观，风格，而不会影响布局的则就叫称为重绘。
区别：
    他们的区别很大：
     回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
     当页面布局和几何属性改变时就需要回流


性能优化
1、 精灵图
2、图片懒加载
3、减少HTTP请求
4、减少DOM元素数量
5、减小cookie大小
6、前端代码结构的优化

git如何查看所有分支  常用命令

git branch 查看本地所有分支
git status 查看当前状态
git commit 提交
git branch -a 查看所有的分支
git branch -r 查看远程所有分支
git commit -am "init" 提交并且加注释
git remote add origin git@192.168.1.119:ndshow
git push origin master 将文件给推到服务器上
git remote show origin 显示远程库origin里的资源
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev

git merge origin/dev 将分支dev与当前分支进行合并
 2
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m "This is the message describing the commit" 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m "remove" 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来



项目中难点



宏任务微任务

宏任务
宏任务指执行栈中待执行的任务，计时器，事件回调，http回调都是宏任务。

微任务
微任务指执行栈清空后立即执行的任务（VIP通道，贵族就是不一样~），Promise 和 MutationObserver都是微任务。


{  计算属性computed和watch的区别

计算属性：一个数据属性在它所依赖的属性发生变化时，也要发生变化，这种情况下，我们最好使用计算属性。

watch适合处理的场景是，侦听一个数的变化，当该数据变化，来处理其他与之相关数据的变化（该数据影响别的多个数据）==当数据发生变化时，执行异步操作或较大开销操作的情况。
}


const let ver 区别
vue react区别
vue双向数据绑定原理
                                  什么是原型链  （原型）
                             1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
                             2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链


xss攻击
 在script标签
 大小写攻击
窃取网页浏览中的cookie值


